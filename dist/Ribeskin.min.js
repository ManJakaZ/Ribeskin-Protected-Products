(function(){
  // Scope to product LISTS (won't affect PDP)
  const LIST_SEL   = '.product-list';
  const ITEM_SEL   = '.product-list-item, .ProductList-item, [data-item-id], li, article';
  const TITLE_SEL  = '.product-list-item-title, .ProductItem__title, .product-title, .list-item-title, h3, h2';
  const PRICE_SEL  = '.product-list-item-price';
  const BTN_WRAP   = '.sqs-add-to-cart-button-wrapper';
  const NAME_RE    = /ribeskin/i;

  const URL_SELECTORS = [
    '.product-list-item-title a',
    '.product-list-item-image a',
    '.image a',
    '.sqs-product-image a',
    'a[href*="/product/"]',
    'a[href*="/shop/"]',
    'a[href^="/"]'
  ];

  function normalizeUrl(href){
    if (!href) return '';
    // if it's full URL, keep it; otherwise ensure a leading slash
    if (/^https?:\/\//i.test(href)) return href;
    return href.startsWith('/') ? href : '/'+href.replace(/^#+/, '');
  }

  function resolveProductUrl(card){
    // 1) Any anchor inside the card that points to product
    for (const sel of URL_SELECTORS){
      const a = card.querySelector(sel);
      if (a && a.getAttribute('href') && a.getAttribute('href') !== '#'){
        return normalizeUrl(a.getAttribute('href'));
      }
    }
    // 2) Data attributes on card or its ancestors
    let n = card;
    while (n && n.nodeType === 1){
      const d = n.getAttribute('data-item-url') || n.getAttribute('data-product-url');
      if (d) return normalizeUrl(d);
      n = n.parentElement;
    }
    return '';
  }

  function processItem(item){
    if (!item || item.dataset.qsProcessed === '1') return;
    const list = item.closest(LIST_SEL);
    if (!list) return; // guard: only in list/collection grids

    const titleEl = item.querySelector(TITLE_SEL);
    const title   = titleEl ? titleEl.textContent.trim() : '';
    if (!NAME_RE.test(title)) return; // only Ribeskin

    item.dataset.qsProcessed = '1';
    item.dataset.qsRibeskin  = '1';

    // Hide price (JS backup to CSS)
    const price = item.querySelector(PRICE_SEL);
    if (price) price.style.display = 'none';

    // Get the product page URL
    const href = resolveProductUrl(item);

    // Replace the cart button with a clean link that forces navigation
    const wrap = item.querySelector(BTN_WRAP);
    if (wrap){
      const link = document.createElement('a');
      link.href = href || '#';
      link.className = 'sqs-add-to-cart-button sqs-suppress-edit-mode sqs-editable-button sqs-button-element--primary';
      link.setAttribute('role','button');
      link.innerHTML = `
        <div class="sqs-add-to-cart-button-inner">
          <span class="add-to-cart-text">Show Me Prices</span>
        </div>
      `;
      // Force navigation even if Squarespace tries to intercept
      const nav = (e) => {
        if (!href) return; // let it noop if missing
        e.preventDefault(); e.stopPropagation();
        window.location.href = href;
      };
      link.addEventListener('click', nav, { capture: true });
      link.addEventListener('mousedown', nav, { capture: true });
      link.addEventListener('touchstart', nav, { capture: true, passive: false });

      wrap.replaceChildren(link);
    }
  }

  function initList(list){
    list.querySelectorAll(ITEM_SEL).forEach(processItem);
    // Watch only this list for lazy-loaded items
    const mo = new MutationObserver(muts => {
      for (const m of muts){
        for (const n of m.addedNodes){
          if (n.nodeType !== 1) continue;
          if (n.matches?.(ITEM_SEL)) processItem(n);
          else if (n.querySelector) n.querySelectorAll(ITEM_SEL).forEach(processItem);
        }
      }
    });
    mo.observe(list, { childList: true, subtree: true });
  }

  document.querySelectorAll(LIST_SEL).forEach(initList);
})();
